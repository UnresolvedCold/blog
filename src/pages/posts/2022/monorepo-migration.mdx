---
title: Combining multiple git repositories into a single repository retaining all the commit histories
description: One of the task assigned to me by my company was to migrate multiple git repos on Bitbucket to GitHub as a mono-repo. Let's see how I did it.
pubDate: Dec 12, 2022
draft: 
---
import BlogImage from "@components/BlogImage.astro"

## The Problem

In my company, we were having multiple maven projects that were dependent on each other. 
And for every project we were maintaining a separate `git` repository hosted on Bitbucket.

Due to certain use-case, we wanted to migrate all our Bitbucket repos to GitHub. 
And to avoid any circular dependency issue we also wanted to combine all these related repos into a mono-repo system. 
We wanted to combine all these repos as a subdirectory of a larger parent project (which in our case was a maven parent). 

#### `Folder structure`
```bash
parent
 ├── POM.XML        // Our new parent POM
 ├── .git           // This is our new git that will contain all the histories
 ├── repo1         
 │   ├── POM.XML
 │   ├── ...
 │   └── .git       // This git will be removed
 ├── repo2
 │   ├── POM.XML
 │   ├── ...
 │   └── .git       // This git will be removed
 └── repo3
     ├── POM.XML
     ├── ...
     └── .git       // This git will be removed
```

Combining the repos is the easier part. 
All you need to do is create a master `POM.XML` that will contain all the sub-repos as submodules. 

The difficult part is retaining all the histories. 
As each repository has it's own `.git`, removing this will delete all the associated histories.
After which we won't be able to identify the code changes, commits and most importantly the branches. 

At GreyOrange, we maintian a `develop` branch and certain `release` branches for each repo.
We wanted to merge their histories so that we can have all our commits on the same branch as they were originally. 
We cannot retain the commit hash as the folder structure has changed but we want all our commit messages. 

We also had many feature branches but they were mostly independent so merging wasn't required for them. 

## A bit about git 

Running `git init` creates a new `.git` directory. This directory contains everything `git` needs to do it's work.

### `objects` directory

The `objects` directory inside `.git` contains all the blobs, trees and commits. 
Blobs are a type of data structure contains a compressed info related to the changed files. 
Each time you run `git add .`, a new blob is created inside the `objects` directory. 

```bash
> ls .git/objects
info/     pack/

# Create a file with it's content as test
> echo "test" >> test.txt
> ls .
    test.txt 

# adding changes creates blob of the changed files
> git add .
> ls .git/objects
0c/   info/    pack/      # 0c and 9d are the 2 directories containing the changes

> ls .git/objects/0c
2c5f41c83de09587dfe46d5a5382eddf5bb77f
# The complete hash of the blob is 0c2c5f41c83de09587dfe46d5a5382eddf5bb77f
# Note: The first 2 letters are the directory name

# You can also view the contents of the blob
> git cat-file blob 0c2c5f41c83de09587dfe46d5a5382eddf5bb77f
test
```

Multiple blobs are combined together to form a tree data srructure. 
Generally this happens before a commit.
But you can run `git write-tree` to generate a tree of recent blobs. 
These trees are also stored inside `objects` directory.

```bash
> git write-tree    # This outputs the hash associated with the tree generated
56bac5fc9c69776a5c67daa2225ef9b2e1edd4f6

# Trees are stored in the same manner
> ls .git/objects/56
bac5fc9c69776a5c67daa2225ef9b2e1edd4f6

# You can also view the content of a tree file
# It contains a reference to the blobs or trees
> git cat-file -p 56bac5fc9c69776a5c67daa2225ef9b2e1edd4f6
100644 blob 0c2c5f41c83de09587dfe46d5a5382eddf5bb77f    test.txt
# 0c2c5f... is the hash of the blob created above
```

A tree represents the state of the system. Commits are just hashed trees. 
They are also stored in the same manner. 

```bash
> git commit -m "initial commit"

> ls .git/objects
0c/   52/   56/   info/    pack/    # 52 is newly generated directory

> git cat-file -p 5203c0048b4795669114fcdb261dc5bb4e77a54f
tree 56bac5fc9c69776a5c67daa2225ef9b2e1edd4f6       # This is the hash of the tree we created above
author Shubham Kumar (Product Architecture) <shubham.kumar@greyorange.com> 1670872587 +0530
committer Shubham Kumar (Product Architecture) <shubham.kumar@greyorange.com> 1670872587 +0530
```
A commit just contains the recent tree hash and inforamtion on author, time and committer. 

### `refs` directory

The `refs` directory contains the reference to commits. 
There are 2 types of reference - branch and tags. 
Tags identify a unique commit while branch points to the latest child along the tree. 

```bash
> ls .git/refs/heads
master               # There is just one branch right now

# Let's create a new branch and see what happens
> git checkout -b dev
Switched to a new branch 'dev'

> ls .git/ref/heads
dev   master        # Now you can see both the branches

> cat .git/ref/heads/dev
5203c0048b4795669114fcdb261dc5bb4e77a54f 
# Points to the latest commit. This is the exact same hash of the commit we created above. 

> git commit -m "commit to dev" --allow-empty
[dev 9d6d972] commit to dev

> cat .git/ref/heads/dev
9d6d972066b774e89343e57f2eb053559bf3f22c 
# Creating a new commit changes the contents of the active branch.
```

### `logs` directory

This contains the history of every branch. 
Everytime you change the branch using `git checkout <branch-name>` or update the tip, `logs/HEAD` is updated. 
`logs/refs/heads` contains the history of commits for a particular branch. 
This is a safety net. You can easily retrieve your work even after a rebase. 

```bash
# To view the logs/HEAD
> git reflog
9d6d972 (HEAD -> dev) HEAD@{0}: checkout: moving from master to dev
5203c00 (master) HEAD@{1}: checkout: moving from dev to master
9d6d972 (HEAD -> dev) HEAD@{2}: commit: commit to dev
5203c00 (master) HEAD@{3}: checkout: moving from master to dev
5203c00 (master) HEAD@{4}: commit (initial): initial commit
```

