#+title: non-associative-sorting
#+AUTHOR: Shubham Kumar
#+DATE: 2024-03-17
#+PROPERTY: description: One method to sort the elements when there is no associative ordering b/w them. This means a < b and b < c does not imply a < c.
#+PROPERTY: draft: true
#+PROPERTY: ideaDate: Mar 17, 2024

* Introduction

During my time in GreyOrange, I faced a problem where we needed to sort an array of non-associative elements.
This means, if I have 3 elements ~a, b, c~ with ~a < b~ and ~b < c~. I cannot say ~a < c~ or ~c > b~ or ~b > a~.
With a mind trained in everyday Mathematics, this seems is quite non-intuitive.
Let me explain this a bit further.

* Detailed Explanation

Let's say a, b and c are set of numerically sorted integers with ~a=(0,0), b=(0,1)~ and ~c=(1,1)~.
And my comparator compares x and y such that ~x < y~ if any element of y > largest element of x and ~x > y~ if any element of y < smallest element of x. Consider them equal otherwise.

Using the above logic, a < b because 1 is an element of b which is greater than the largest element of a which is 0.
Using the same logic ~a < c~.
Comparing c and b. Is any alement of b > 1 (largest element of c) -> NO. Is any element of b < 1 (smallest element of c) -> Yes.
So ~c > b~.
using the same logic ~c > a~.

Which means we have ~a < b~ and ~b < c~ and so the sorted order for these elements is ~a < b < c~.

But what about comparing b and c.
Is any element of c > largest element of b -> NO.
Is any element of c < smallest element of b -> NO.
So b == c? Yes

You can view the whole table of comparison.
| ele1     | ele2     | min(ele1) | max(ele1) | compare (ele1, ele2) | Comments      |
|----------+----------+-----------+-----------+----------------------+---------------|
| a (0, 0) | a (0, 0) |         0 |         0 | a == a               |               |
| a (0, 0) | b (0, 1) |         0 |         0 | a < b                | 1 > max(ele1) |
| a (0, 0) | c (1, 1) |         0 |         0 | a < c                | 1 > max(ele1) |
| b (0, 1) | a (0, 0) |         0 |         1 | b == a               |               |
| b (0, 1) | b (0, 1) |         0 |         1 | b == b               |               |
| b (0, 1) | c (1, 1) |         0 |         1 | b == c               |               |
| c (1, 1) | a (0, 0) |         1 |         1 | c > a                | 0 < min(ele1)  |
| c (1, 1) | b (0, 1) |         1 |         1 | c > b                | 0 < min(ele1)  |
| c (1, 1) | c (1, 1) |         1 |         1 | c == c               |               |

This is what we call non-associativity and non-commutativity.
The merge sort will fail here.
The main question is how can we write an algorithm to sort these non-associative elements?

* Why merge sort fails here?

Let's try to solve this using ~Java~ with a custom comparator.
This ~Collections.sort~ method uses a modified version of Merge sort called Tim sort.
Understanding why this fails for merge sort will give us an insight why it fails for other algorithms also.
But if you want to learn more about Tim Sort refer -- https://www.geeksforgeeks.org/timsort/

** Merge sort code

Merge sort consists of 3 things - divide, compare and merge.
It just says, divide the array in 2 halves and merge them in order.
Dividing the array takes ~O(nlogn)~ while merging is an ~O(n)~ operation.

Let's implement the mergesort and merge logic as follows.
~mergeSort~ function divides the array in 2 parts and sorts both and merge them.
~merge~ function is just comparing the elememts of both the arrays and creating a result based on that.

#+NAME: MERGE_SORT_IMPLEMENTATION
#+begin_src java :noeval
public static <T> void mergeSort(List<T> arr, Comparator<? super T> cmp) {
    System.out.println("In: "+arr);
    if (arr.size() < 2) {
        return;
    }
    int mid = arr.size() / 2;
    List<T> left = arr.subList(0, mid);
    List<T> right = arr.subList(mid, arr.size());
    mergeSort(left, cmp);
    mergeSort(right, cmp);
    merge(new ArrayList(arr), left, right, cmp);
    System.out.println("Out: "+arr);
}

private static <T> void merge(List<T> result, List<T> left, List<T> right, Comparator<? super T> cmp) {
    int i = 0, j = 0, k = 0;
    while (i < left.size() && j < right.size()) {
        if (cmp.compare(left.get(i), right.get(j)) > 0) {
            System.out.println("Compare: "+left.get(i)+","+right.get(j)+" :Choose "+right.get(j));
            result.set(k++, right.get(j++));
        } else if (cmp.compare(left.get(i), right.get(j)) < 0){
            System.out.println("Compare: "+left.get(i)+","+right.get(j)+" :Choose "+left.get(i));
            result.set(k++, left.get(i++));
        } else {
            System.out.println("Compare: "+left.get(i)+","+right.get(j)+" :Choose "+right.get(j));
            result.set(k++, right.get(j++));
        }
    }
    while (i < left.size()) {
        System.out.println("Rest of the left: "+left.get(i));
        result.set(k++, left.get(i++));
    }
    while (j < right.size()) {
        System.out.println("Rest of the right: "+right.get(j));
        result.set(k++, right.get(j++));
    }
}
#+end_src

#+begin_src java :noweb yes
import java.util.*;

public class NonAssociativeSort
{
<<MERGE_SORT_IMPLEMENTATION>>

  public static void main(String [] args) {
    // List of elements
    List<List<Integer>> arr = new ArrayList<>();
    arr.add(List.of(0,1));
    arr.add(List.of(1,1));
    arr.add(List.of(0,0));

    // Logic fpr comparison
    mergeSort(arr, (a, b) -> {
      for (int e : b) {
        if (e > a.get(a.size()-1)){
          System.out.println(b + " > " + a);
          return -1;
        }
        else if (e < a.get(0)){
          System.out.println(b + " < " + a);
          return 1;
        }
      }
      return 0;
    });

    System.out.println("final:" + arr);
  }
}
#+end_src

#+RESULTS:
#+begin_example
In: [[0, 1], [1, 1], [0, 0]]
In: [[0, 1]]
In: [[1, 1], [0, 0]]
In: [[1, 1]]
In: [[0, 0]]
[0, 0] < [1, 1]
Compare: [1, 1],[0, 0] :Choose [0, 0]
Rest of the left: [1, 1]
Out: [[1, 1], [0, 0]]
Compare: [0, 1],[1, 1] :Choose [1, 1]
Compare: [0, 1],[0, 0] :Choose [0, 0]
Rest of the left: [0, 1]
Out: [[0, 1], [1, 1], [0, 0]]
final:[[0, 1], [1, 1], [0, 0]]
#+end_example

** Explanation

The ~Merge~ sort failed in this case.
Here, a=(0,0), b=(0,1) and c=(1,1)

#+begin_src plantuml :file ../src/images/posts/blog-non-associative-sorting/merge-sort-explained.png
@startuml
[bca] -D-> [b] : divide
[bca] -D-> [ca] : divide
[ca] -D-> [c] : divide
[ca] -D-> [a] : divide
[c] <-R-> [a] : Comparing c and a\nc > a\nChoose a
[c] -D-> [ac]
[a] -D-> [ac]
[b] -D-> [ b]
[ b] -D-> [b ]
[b ] <-R-> [ac] : Comparing b and a\nb == a\nChoose b
[b ] -D-> [bac]
[ac] -D-> [bac]
@enduml
#+end_src

#+RESULTS:
[[file:../src/images/posts/blog-non-associative-sorting/merge-sort-explained.png]]
